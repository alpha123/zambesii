#ifndef _ZKCM_TIMER_DRIVER_H
	#define _ZKCM_TIMER_DRIVER_H

	#include <__kstdlib/__ktypes.h>
	#include <kernel/common/timerTrib/timeTypes.h>
	#include <kernel/common/processId.h>

struct zkcmTimerDriverS
{
	error_t (*initialize)(void);
	error_t (*shutdown)(void);
	error_t (*suspend)(void);
	error_t (*restore)(void);

	status_t (*enableTimerSource)(struct zkcmTimerSourceS *timerSource);
	void (*disableTimerSource)(struct zkcmTimerSourceS *timerSource);

	status_t (*setTimerSourcePeriodic)(
		struct zkcmTimerSourceS *timerSource,
		struct timeS interval);

	status_t (*setTimerSourceOneshot)(
		struct zkcmTimerSourceS *timerSource,
		struct timestampS timeout);

	/* When a timer source has a 'capability.precision' other than
	 * EXACT or NEGLIGABLE, this API call will return the exact nanosecond
	 * underflow or overflow for the period passed as an argument.
	 *
	 * For example, on the IBM-PC, the RTC can generate a timing signal that
	 * has an /almost/ 1ms period, but underflows the exact precision of 1ms
	 * by a few fractions of a second. It actually generates a period of
	 * 0.976ms (0.976562). For this timer, the driver would set the
	 * "precision" property to PRECISION_UNDERFLOW, and when
	 * getPrecisionDisparityForPeriod(myTimer, ZKCM_TIMERSRC_PERIOD_1ms)
	 * is called, it would return the nanosecond disparity between the
	 * requested period and the actual period generated by the timer source.
	 **/
	uarch_t (*getPrecisionDisparityForPeriod)(
		struct zkcmTimerSourceS *timerSource,
		ubit32 period);
};

#endif

