#ifndef _ZKCM_TIMER_SOURCE_H
	#define _ZKCM_TIMER_SOURCE_H

	#include <chipset/zkcm/device.h>
	#include <__kstdlib/__ktypes.h>
	#include <__kstdlib/__kflagManipulation.h>
	#include <__kclasses/singleWaiterQueue.h>
	#include <kernel/common/sharedResourceGroup.h>
	#include <kernel/common/waitLock.h>
	#include <kernel/common/processId.h>
	#include <kernel/common/timerTrib/timeTypes.h>
	#include <kernel/common/floodplainn/floodplainnStream.h>
	#include <kernel/common/cpuTrib/cpuTrib.h>

/**	Constants used with struct zkcmTimerSourceS.
 **/
// Values for zkcmTimerDeviceC.capabilities.modes.
#define ZKCM_TIMERDEV_CAP_MODE_PERIODIC		(1<<0)
#define ZKCM_TIMERDEV_CAP_MODE_ONESHOT		(1<<1)

// Values for zkcmTimerDeviceC.state.flags.
#define ZKCM_TIMERDEV_STATE_FLAGS_ENABLED	(1<<0)
#define ZKCM_TIMERDEV_STATE_FLAGS_LATCHED	(1<<1)

class zkcmTimerDeviceC;

struct zkcmTimerEventS
{
	zkcmTimerDeviceC	*device;
	floodplainnStreamC	*latchedStream;
	timeS			irqTime;
};

class zkcmTimerDeviceC
:
public zkcmDeviceBaseC
{
friend class timerTribC;

public:
	enum timerTypeE { PER_CPU=0, CHIPSET };
	enum ioLatencyE { LOW=0, MODERATE, HIGH };
	enum precisionE { EXACT=0, NEGLIGABLE, OVERFLOW, UNDERFLOW };
	enum modeE { PERIODIC=0, ONESHOT, UNINITIALIZED };

	zkcmTimerDeviceC(
		timerTypeE type, ubit32 modes,
		ubit32 periodicMinPeriod, ubit32 periodicMaxPeriod,
		ubit32 oneshotMinTimeout, ubit32 oneshotMaxTimeout,
		ioLatencyE ioLatency, precisionE precision,
		zkcmDeviceC *device)
	:
	zkcmDeviceBaseC(device),
	capabilities(
		type, modes,
		periodicMinPeriod, periodicMaxPeriod,
		oneshotMinTimeout, oneshotMaxTimeout,
		ioLatency, precision)
	{}

public:
	virtual error_t initialize(void)
	{
		irqEventCache = cachePool.createCache(sizeof(zkcmTimerEventS));
		if (irqEventCache == __KNULL)
		{
			__kprintf(WARNING"ZKCM-Timer: Creating obj cache "
				"failed for device \"%s\".\n",
				getBaseDevice()->shortName);

			return ERROR_MEMORY_NOMEM;
		};

		return irqEventQueue.initialize();
	}

	virtual error_t shutdown(void)=0;
	virtual error_t suspend(void)=0;
	virtual error_t restore(void)=0;

	virtual error_t enable(void)=0;
	virtual void disable(void)=0;
	sarch_t isEnabled(void)
	{
		uarch_t		flags;

		state.lock.acquire();
		flags = state.rsrc.flags;
		state.lock.release();

		return __KFLAG_TEST(flags, ZKCM_TIMERDEV_STATE_FLAGS_ENABLED);
	}

	// Call disable() before setting timer options, then enable() again.
	virtual status_t setPeriodicMode(struct timeS interval)=0;
	virtual status_t setOneshotMode(struct timeS timeout)=0;
	virtual void getOneshotModeMinMaxTimeout(timeS *min, timeS *max)
	{
		min->nseconds = capabilities.oneshotMinTimeout;
		max->nseconds = capabilities.oneshotMaxTimeout; 
	}
	
	virtual void getPeriodicModeMinMaxPeriod(timeS *min, timeS *max)
	{
		min->nseconds = capabilities.periodicMinPeriod;
		max->nseconds = capabilities.periodicMaxPeriod;
	}

	/* When a timer source has a 'capability.precision' other than
	 * EXACT or NEGLIGABLE, this API call will return the exact nanosecond
	 * underflow or overflow for the period passed as an argument.
	 *
	 * For example, on the IBM-PC, the RTC can generate a timing signal that
	 * has an /almost/ 1ms period, but underflows the exact precision of 1ms
	 * by a few fractions of a second. It actually generates a period of
	 * 0.976ms (0.976562). For this timer, the driver would set the
	 * "precision" property to PRECISION_UNDERFLOW, and when
	 * getPrecisionDisparityForPeriod(myTimer, ZKCM_TIMERDEV_PERIOD_1ms)
	 * is called, it would return the nanosecond disparity between the
	 * requested period and the actual period generated by the timer source.
	 **/
	virtual uarch_t getPrecisionDiscrepancyForPeriod(ubit32 period)=0;

	singleWaiterQueueC<zkcmTimerEventS> *getEventQueue(void)
	{
		return &irqEventQueue;
	}

	error_t latch(floodplainnStreamC *stream)
	{
		state.lock.acquire();

		if (__KFLAG_TEST(
			state.rsrc.flags,
			ZKCM_TIMERDEV_STATE_FLAGS_LATCHED))
		{
			state.lock.release();
			return ERROR_RESOURCE_BUSY;
		};

		state.rsrc.latchedStream = stream;
		__KFLAG_SET(
			state.rsrc.flags, ZKCM_TIMERDEV_STATE_FLAGS_LATCHED);

		state.lock.release();
		return ERROR_SUCCESS;
	}

	void unlatch(void)
	{
		cpuStreamC	*currCpu;

		// If it's not the owning process, deny the attempt.
		currCpu = cpuTrib.getCurrentCpuStream();

		// This condition needs to check the floodplain binding.
		if (PROCID_PROCESS(currCpu->taskStream.currentTask->id)
			== PROCID_PROCESS(state.rsrc.latchedStream->id))
		{
			state.lock.acquire();

			__KFLAG_UNSET(
				state.rsrc.flags,
				ZKCM_TIMERDEV_STATE_FLAGS_LATCHED);

			state.lock.release();
		};
	}

	// Returns 1 if latched, 0 if not latched.
	sarch_t getLatchState(floodplainnStreamC **latchedStream)
	{
		state.lock.acquire();

		if (__KFLAG_TEST(
			state.rsrc.flags, ZKCM_TIMERDEV_STATE_FLAGS_LATCHED))
		{
			*latchedStream = state.rsrc.latchedStream;

			state.lock.release();
			return 1;
		};

		state.lock.release();
		return 0;
	}

	sarch_t validateCallerIsLatched(void)
	{
		floodplainnStreamC		*stream;
		taskC			*currTask;

		currTask = cpuTrib.getCurrentCpuStream()
			->taskStream.currentTask;

		// Replace with floodplain binding check.
		if (getLatchState(&stream)
			&& PROCID_PROCESS(stream->id)
				== PROCID_PROCESS(currTask->id))
		{
			return 1;
		} else {
			return 0;
		};
	};

public:

	struct capabilitiesS
	{
		capabilitiesS(
			timerTypeE type, ubit32 modes,
			ubit32 periodicMinPeriod, ubit32 periodicMaxPeriod,
			ubit32 oneshotMinTimeout, ubit32 oneshotMaxTimeout,
			ioLatencyE ioLatency, precisionE precision)
		:
		type(type), ioLatency(ioLatency), precision(precision),
		modes(modes),
		periodicMinPeriod(periodicMinPeriod),
		periodicMaxPeriod(periodicMaxPeriod),
		oneshotMinTimeout(oneshotMinTimeout),
		oneshotMaxTimeout(oneshotMaxTimeout)
		{}
		
		timerTypeE	type;
		ioLatencyE	ioLatency;
		precisionE	precision;
		// Modes (bitfield): PERIODIC, ONESHOT.
		ubit32		modes;
		ubit32		periodicMinPeriod, periodicMaxPeriod;
		ubit32		oneshotMinTimeout, oneshotMaxTimeout;
	} capabilities;

protected:
	zkcmTimerEventS *allocateIrqEvent(void)
	{
		return (zkcmTimerEventS *)irqEventCache->allocate();
	};

	void freeIrqEvent(zkcmTimerEventS *event)
	{
		irqEventCache->free(event);
	}

protected:
	struct stateS
	{
		stateS(void)
		:
		flags(0), latchedStream(0), mode(UNINITIALIZED), period(0)
		{}

		ubit32			flags;
		// Floodplain Stream for the process using this timer device.
		floodplainnStreamC	*latchedStream;
		// Current mode: periodic/oneshot. Valid if FLAGS_ENABLED set.
		modeE			mode;
		// For periodic mode: stores the current timer period in ns.
		ubit32			period;
		// For oneshot mode: stores the current timeout date and time.
		timeS			currentTimeout;
		timeS			currentInterval;
	};

	sharedResourceGroupC<waitLockC, stateS>	state;
	singleWaiterQueueC<zkcmTimerEventS>	irqEventQueue;
	slamCacheC				*irqEventCache;
};

#endif

