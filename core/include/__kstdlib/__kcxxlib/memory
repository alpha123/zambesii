#ifndef ___K_CXX_LIB_POINTER_H
	#define ___K_CXX_LIB_POINTER_H

	#include <__kstdlib/__ktypes.h>
	#include <__kstdlib/__kcxxlib/new>

class memoryStreamC;
class vaddrSpaceStreamC;

namespace pointer
{
	void vmemUnmapAndFree(
		void *vaddr, uarch_t nPages, status_t nMapped,
		vaddrSpaceStreamC *vasStream);

	void streamFree(void *vaddr, memoryStreamC *memStream);
}

template <class type>
class ptrC
{
protected:
	explicit ptrC(type *_p=NULL) : p(_p) {}
	~ptrC(void) { reset(); }

public:	ptrC &operator =(ptrC &_p) { reset(_p.release()); };

public:
	// Equivalent to std::unique_ptr<>::get().
	type *get(void) { return p; }
	type **addressOf(void) { return &p; }
	// Equivalent to std::unique_ptr<>::reset(void *=NULL).
	void reset(type *_p=NULL) { p = _p; }
	// Equivalent to std::unique_ptr<>::release().
	type *release(void)
	{
		type	*tmp=p;
		p = NULL;
		return tmp;
	}

	type *operator ->() { return p; }
	type &operator *() { return *p; }
	type &operator [](int i) { return p[i]; }
	ptrC &operator =(type *_p) { p = _p; return *this; }
	int operator ==(type *_p) { return p == _p; }
	int operator >(type *_p) { return p > _p; }
	int operator <(type *_p) { return p < _p; }
	ptrC &operator++(void) { ++p; return *this; }
	ptrC &operator--(void) { --p; return *this; }

	// We refuse to provide operators + and -. Use array indexing instead.
private:
	virtual void _(void) = 0;

protected:
	type	*p;
};

class default_deleterC {};
class array_deleterC {};

template <class type, class deleter>
class heapPtrC
:
public ptrC<type>
{
public:
	explicit heapPtrC(type *_p=NULL)
	:
	ptrC<type>(_p)
	{}

	~heapPtrC(void) { reset(); }

	heapPtrC &operator =(heapPtrC &_p)
		{ reset(_p.release()); return *this; }

public:
	heapPtrC &operator =(type *_p)
		{ ptrC<type>::operator =(_p); return *this; }

	void reset(type *_p=NULL) { ptrC<type>::reset(_p); }

private:
	virtual void _(void) = 0;
};

template <class type>
class heapObjC
:
public heapPtrC<type, default_deleterC>
{
public:
	explicit heapObjC(type *_p=NULL)
	:
	heapPtrC<type, default_deleterC>(_p)
	{}

	~heapObjC(void) { reset(); }

	heapObjC &operator =(heapObjC &_p)
		{ reset(_p.release()); return *this; };

public:
	heapObjC &operator =(type *_p) {
		heapPtrC<type, default_deleterC>::operator =(_p); return *this;
	}

	void reset(type *_p=NULL)
	{
		if (this->get() != NULL) { delete this->get(); };
		heapPtrC<type, default_deleterC>::reset(_p);
	};

private:
	virtual void _(void) {}
};

template <class type>
class heapArrC
:
public heapPtrC<type, array_deleterC>
{
public:
	explicit heapArrC(type *_p=NULL)
	:
	heapPtrC<type, array_deleterC>(_p)
	{}

	~heapArrC(void) { reset(); }

	heapArrC &operator =(heapArrC &_p)
		{ reset(_p.release()); return *this; };

public:
	heapArrC &operator =(type *_p) {
		heapPtrC<type, array_deleterC>::operator =(_p); return *this;
	}

	void reset(type *_p=NULL)
	{
		if (this->get() != NULL) { delete[] this->get(); };
		heapPtrC<type, array_deleterC>::reset(_p);
	};

private:
	virtual void _(void) {}
};

template <class type>
class loosePageC
:
public ptrC<type>
{
public:
	explicit loosePageC(type *_p=NULL)
	:
	ptrC<type>(_p), nPages(0), nMapped(0),  vasStream(NULL)
	{}

	~loosePageC(void) { reset(); }

	loosePageC &operator =(loosePageC &_p)
	{
		reset(_p.release(), _p.nPages, _p.nMapped, _p.vasStream);
		return *this;
	}

public:
	loosePageC &operator =(type *_p)
		{ ptrC<type>::operator =(_p); return *this; }

	void reset(
		type *_p=NULL, uarch_t _nPages=0, status_t _nMapped=0,
		vaddrSpaceStreamC *_vasStream=NULL)
	{
		if (this->get() != NULL && nPages > 0)
		{
			pointer::vmemUnmapAndFree(
				this->get(), nPages, nMapped, vasStream);
		};

		nPages = _nPages;
		nMapped = _nMapped;
		vasStream = _vasStream;
		ptrC<type>::reset(_p);
	};

private:
	virtual void _(void) {}

public:
	vaddrSpaceStreamC	*vasStream;
	uarch_t			nPages;
	status_t		nMapped;
};

template <class type>
class streamMemC
:
public ptrC<type>
{
public:
	explicit streamMemC(type *_p=NULL) : ptrC<type>(_p), memStream(NULL) {}
	~streamMemC(void) { reset(); }

	streamMemC &operator =(streamMemC &_p)
		{ reset(_p.release(), _p.memStream); return *this; }

public:
	streamMemC &operator =(type *_p)
		{ ptrC<type>::operator =(_p); return *this; }

	void reset(type *_p=NULL, memoryStreamC *_memStream=NULL)
	{
		if (this->get() != NULL) {
			pointer::streamFree(this->get(), memStream);
		};

		memStream = _memStream;
		ptrC<type>::reset(_p);
	}

private:
	virtual void _(void) {}

public:
	memoryStreamC		*memStream;
};

#endif

